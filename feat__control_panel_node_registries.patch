Subject: [PATCH] feat: control panel node registries
---
Index: src/main/java/com/hbm/inventory/control_panel/DataValue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/DataValue.java b/src/main/java/com/hbm/inventory/control_panel/DataValue.java
--- a/src/main/java/com/hbm/inventory/control_panel/DataValue.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/DataValue.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -1,20 +1,20 @@
 package com.hbm.inventory.control_panel;
 
+import com.hbm.main.MainRegistry;
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagFloat;
 import net.minecraft.nbt.NBTTagString;
 
-public abstract class DataValue {
-	public abstract float getNumber();
-	public abstract boolean getBoolean();
-	public abstract String toString();
-	public abstract DataType getType();
-	public abstract <E extends Enum<E>> E getEnum(Class<E> clazz);
-	public abstract NBTBase writeToNBT();
-	public abstract void readFromNBT(NBTBase nbt);
+public interface DataValue {
+	float getNumber();
+	boolean getBoolean();
+	DataType getType();
+	<E extends Enum<E>> E getEnum(Class<E> clazz);
+	NBTBase writeToNBT();
+	void readFromNBT(NBTBase nbt);
 	
-	public static DataValue newFromNBT(NBTBase base){
+	static DataValue newFromNBT(NBTBase base){
 		DataValue val = null;
 		try {
 			if(base instanceof NBTTagCompound) {
@@ -28,21 +28,21 @@
 				val.readFromNBT(base);
 			}
 		} catch(Exception x) {
-			x.printStackTrace();
+			MainRegistry.logger.catching(x);
 			return null;
 		}
 		return val;
 	}
 	
-	public static enum DataType {
+	enum DataType {
 		GENERIC(new float[]{0.5F, 0.5F, 0.5F}),
 		NUMBER(new float[]{0.4F, 0.6F, 0}),
 		STRING(new float[]{0, 1, 1}),
 		ENUM(new float[]{0.29F, 0, 0.5F});
 		
-		private float[] color;
+		private final float[] color;
 		
-		private DataType(float[] color){
+		DataType(float[] color){
 			this.color = color;
 		}
 		
Index: src/main/java/com/hbm/inventory/control_panel/DataValueEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/DataValueEnum.java b/src/main/java/com/hbm/inventory/control_panel/DataValueEnum.java
--- a/src/main/java/com/hbm/inventory/control_panel/DataValueEnum.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/DataValueEnum.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -3,7 +3,7 @@
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagCompound;
 
-public class DataValueEnum<T extends Enum<T>> extends DataValue {
+public class DataValueEnum<T extends Enum<T>> implements DataValue {
 
 	public Enum<T> value;
 	public Class<T> enumClass;
Index: src/main/java/com/hbm/inventory/control_panel/DataValueFloat.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/DataValueFloat.java b/src/main/java/com/hbm/inventory/control_panel/DataValueFloat.java
--- a/src/main/java/com/hbm/inventory/control_panel/DataValueFloat.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/DataValueFloat.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -3,7 +3,7 @@
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagFloat;
 
-public class DataValueFloat extends DataValue {
+public class DataValueFloat implements DataValue {
 
 	public float num;
 	
Index: src/main/java/com/hbm/inventory/control_panel/DataValueString.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/DataValueString.java b/src/main/java/com/hbm/inventory/control_panel/DataValueString.java
--- a/src/main/java/com/hbm/inventory/control_panel/DataValueString.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/DataValueString.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -3,7 +3,7 @@
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagString;
 
-public class DataValueString extends DataValue {
+public class DataValueString implements DataValue {
 
 	public String str;
 	private float floatVal;
Index: src/main/java/com/hbm/inventory/control_panel/controls/ButtonEmergencyPush.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEmergencyPush.java b/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEmergencyPush.java
--- a/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEmergencyPush.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEmergencyPush.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -80,7 +80,7 @@
         {
             NodeGetVar node0 = new NodeGetVar(170, 100, this).setData("isPushed", false);
             ctrl_press.addNode(node0);
-            NodeBoolean node1 = new NodeBoolean(230, 120).setData(NodeBoolean.BoolOperation.NOT);
+            NodeBoolean node1 = new NodeBoolean(230, 120, "not");
             node1.inputs.get(0).setData(node0, 0, true);
             ctrl_press.addNode(node1);
             NodeSetVar node2 = new NodeSetVar(290, 140, this).setData("isPushed", false);
Index: src/main/java/com/hbm/inventory/control_panel/controls/ButtonEncasedPush.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEncasedPush.java b/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEncasedPush.java
--- a/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEncasedPush.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/controls/ButtonEncasedPush.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -124,7 +124,7 @@
             {
                 NodeGetVar node1_0 = new NodeGetVar(170, 100, this).setData("isCoverOpen", false);
                 node1_subsystem.addNode(node1_0);
-                NodeBoolean node1_1 = new NodeBoolean(230, 120).setData(NodeBoolean.BoolOperation.NOT);
+                NodeBoolean node1_1 = new NodeBoolean(230, 120, "not");
                 node1_1.inputs.get(0).setData(node1_0, 0, true);
                 node1_subsystem.addNode(node1_1);
                 NodeSetVar node1_2 = new NodeSetVar(290, 140, this).setData("isCoverOpen", false);
@@ -134,12 +134,12 @@
             node1.inputs.get(0).setData(node0, 1, true);
             ctrl_press.subSystems.put(node1, node1_subsystem);
             ctrl_press.addNode(node1);
-            NodeBoolean node2 = new NodeBoolean(230, 120).setData(NodeBoolean.BoolOperation.NOT);
+            NodeBoolean node2 = new NodeBoolean(230, 120, "not");
             node2.inputs.get(0).setData(node0, 1, true);
             ctrl_press.addNode(node2);
             NodeGetVar node3 = new NodeGetVar(170, 160, this).setData("isCoverOpen", false);
             ctrl_press.addNode(node3);
-            NodeBoolean node4 = new NodeBoolean(290, 130).setData(NodeBoolean.BoolOperation.AND);
+            NodeBoolean node4 = new NodeBoolean(290, 130, "and");
             node4.inputs.get(0).setData(node2, 0, true);
             node4.inputs.get(1).setData(node3, 0, true);
             ctrl_press.addNode(node4);
@@ -148,7 +148,7 @@
             {
                 NodeGetVar node5_0 = new NodeGetVar(170, 100, this).setData("isPushed", false);
                 node5_subsystem.addNode(node5_0);
-                NodeBoolean node5_1 = new NodeBoolean(230, 120).setData(NodeBoolean.BoolOperation.NOT);
+                NodeBoolean node5_1 = new NodeBoolean(230, 120, "not");
                 node5_1.inputs.get(0).setData(node5_0, 0, true);
                 node5_subsystem.addNode(node5_1);
                 NodeSetVar node5_2 = new NodeSetVar(290, 140, this).setData("isPushed", false);
Index: src/main/java/com/hbm/inventory/control_panel/controls/ButtonPush.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/controls/ButtonPush.java b/src/main/java/com/hbm/inventory/control_panel/controls/ButtonPush.java
--- a/src/main/java/com/hbm/inventory/control_panel/controls/ButtonPush.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/controls/ButtonPush.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -108,7 +108,7 @@
         {
             NodeGetVar node0 = new NodeGetVar(170, 100, this).setData("isPushed", false);
             ctrl_press.addNode(node0);
-            NodeBoolean node1 = new NodeBoolean(230, 120).setData(NodeBoolean.BoolOperation.NOT);
+            NodeBoolean node1 = new NodeBoolean(230, 120, "not");
             node1.inputs.get(0).setData(node0, 0, true);
             ctrl_press.addNode(node1);
             NodeSetVar node2 = new NodeSetVar(290, 140, this).setData("isLit", false);
Index: src/main/java/com/hbm/inventory/control_panel/controls/KnobControl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/controls/KnobControl.java b/src/main/java/com/hbm/inventory/control_panel/controls/KnobControl.java
--- a/src/main/java/com/hbm/inventory/control_panel/controls/KnobControl.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/controls/KnobControl.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -129,11 +129,11 @@
             ctrl_press.addNode(node1);
             NodeGetVar node2 = new NodeGetVar(170, 160, this).setData("value", false);
             ctrl_press.addNode(node2);
-            NodeMath node3 = new NodeMath(290, 140).setData(NodeMath.Operation.ADD);
+            NodeMath node3 = new NodeMath(290, 140, "add");
             node3.inputs.get(0).setData(node1, 0, true);
             node3.inputs.get(1).setData(node2, 0, true);
             ctrl_press.addNode(node3);
-            NodeMath node4 = new NodeMath(350, 140).setData(NodeMath.Operation.CLAMP);
+            NodeMath node4 = new NodeMath(350, 140, "clamp");
             node4.inputs.get(0).setData(node3, 0, true);
             node4.inputs.get(1).setDefault(new DataValueFloat(0));
             node4.inputs.get(2).setDefault(new DataValueFloat(10));
Index: src/main/java/com/hbm/inventory/control_panel/controls/SliderVertical.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/controls/SliderVertical.java b/src/main/java/com/hbm/inventory/control_panel/controls/SliderVertical.java
--- a/src/main/java/com/hbm/inventory/control_panel/controls/SliderVertical.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/controls/SliderVertical.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -110,11 +110,11 @@
             node2.inputs.get(1).setDefault(new DataValueFloat(-1));
             node2.inputs.get(2).setDefault(new DataValueFloat(1));
             ctrl_press.addNode(node2);
-            NodeMath node3 = new NodeMath(290, 130).setData(NodeMath.Operation.ADD);
+            NodeMath node3 = new NodeMath(290, 130, "add");
             node3.inputs.get(0).setData(node2, 0, true);
             node3.inputs.get(1).setData(node1, 0, true);
             ctrl_press.addNode(node3);
-            NodeMath node4 = new NodeMath(350, 130).setData(NodeMath.Operation.CLAMP);
+            NodeMath node4 = new NodeMath(350, 130, "clamp");
             node4.inputs.get(0).setData(node3, 0, true);
             node4.inputs.get(1).setDefault(new DataValueFloat(0));
             node4.inputs.get(2).setDefault(new DataValueFloat(5));
Index: src/main/java/com/hbm/inventory/control_panel/controls/SwitchRotaryToggle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/controls/SwitchRotaryToggle.java b/src/main/java/com/hbm/inventory/control_panel/controls/SwitchRotaryToggle.java
--- a/src/main/java/com/hbm/inventory/control_panel/controls/SwitchRotaryToggle.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/controls/SwitchRotaryToggle.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -86,7 +86,7 @@
         {
             NodeGetVar node0 = new NodeGetVar(170, 100, this).setData("isOn", false);
             ctrl_press.addNode(node0);
-            NodeBoolean node1 = new NodeBoolean(230, 120).setData(NodeBoolean.BoolOperation.NOT);
+            NodeBoolean node1 = new NodeBoolean(230, 120, "not");
             node1.inputs.get(0).setData(node0, 0, true);
             ctrl_press.addNode(node1);
             NodeSetVar node2 = new NodeSetVar(290, 140, this).setData("isOn", false);
Index: src/main/java/com/hbm/inventory/control_panel/controls/SwitchToggle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/controls/SwitchToggle.java b/src/main/java/com/hbm/inventory/control_panel/controls/SwitchToggle.java
--- a/src/main/java/com/hbm/inventory/control_panel/controls/SwitchToggle.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/controls/SwitchToggle.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -105,7 +105,7 @@
         {
             NodeGetVar node0 = new NodeGetVar(170, 100, this).setData("isOn", false);
             ctrl_press.addNode(node0);
-            NodeBoolean node1 = new NodeBoolean(230, 120).setData(NodeBoolean.BoolOperation.NOT);
+            NodeBoolean node1 = new NodeBoolean(230, 120, "not");
             node1.inputs.get(0).setData(node0, 0, true);
             ctrl_press.addNode(node1);
             NodeSetVar node2 = new NodeSetVar(290, 140, this).setData("isOn", false);
Index: src/main/java/com/hbm/inventory/control_panel/nodes/Node.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/nodes/Node.java b/src/main/java/com/hbm/inventory/control_panel/nodes/Node.java
--- a/src/main/java/com/hbm/inventory/control_panel/nodes/Node.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/nodes/Node.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -1,6 +1,8 @@
 package com.hbm.inventory.control_panel.nodes;
 
 import com.hbm.inventory.control_panel.*;
+import com.hbm.inventory.control_panel.nodes.registry.BoolOpRegistry;
+import com.hbm.inventory.control_panel.nodes.registry.MathOpRegistry;
 import com.hbm.render.NTMRenderHelper;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.FontRenderer;
@@ -24,9 +26,17 @@
 
 	public boolean cacheValid = false;
 	public DataValue[] evalCache = null;
+
+	public static void registerOps(){
+		MathOpRegistry.init();
+		BoolOpRegistry.init();
+	}
 	
 	public abstract DataValue evaluate(int idx);
 	public abstract NodeType getType();
+	public float[] getColor() {
+		return getType().getColor();
+	}
 	public abstract String getDisplayName();
 	
 	public Node(float x, float y){
@@ -147,7 +157,7 @@
 			NTMRenderHelper.drawGuiRectBatchedColor(posX-edge, posY+6+size, 0, 0.984375F, 40+edge*2, 1+edge, 0.625F, 1, color[0], color[1], color[2], 1);
 			Tessellator.getInstance().draw();
 		}
-		color = getType().getColor();
+		color = getColor();
 		Tessellator.getInstance().getBuffer().begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_COLOR);
 		NTMRenderHelper.drawGuiRectBatchedColor(posX, posY, 0, 0, 40, 6, 0.625F, 0.09375F, 1, 1, 1, 1);
 		NTMRenderHelper.drawGuiRectBatchedColor(posX, posY+6, 0, 0.09375F, 40, size, 0.625F, 0.109375F, 1, 1, 1, 1);
Index: src/main/java/com/hbm/inventory/control_panel/nodes/NodeBoolean.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/nodes/NodeBoolean.java b/src/main/java/com/hbm/inventory/control_panel/nodes/NodeBoolean.java
--- a/src/main/java/com/hbm/inventory/control_panel/nodes/NodeBoolean.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/nodes/NodeBoolean.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -2,28 +2,70 @@
 
 import com.hbm.inventory.control_panel.*;
 import com.hbm.inventory.control_panel.DataValue.DataType;
+import com.hbm.inventory.control_panel.nodes.registry.BoolOpRegistry;
 import net.minecraft.nbt.NBTTagCompound;
+import net.minecraftforge.common.util.Constants;
+
+import java.util.Arrays;
+import java.util.Objects;
 
 public class NodeBoolean extends Node {
 
-    public BoolOperation op = BoolOperation.AND;
+    private BoolOp op;
+    private String opId;
 
     public NodeBoolean(float x, float y) {
+        this(x, y, "and");
+    }
+
+    public NodeBoolean(float x, float y, String opId) {
         super(x, y);
         this.outputs.add(new NodeConnection("Output", this, outputs.size(), false, DataType.NUMBER, new DataValueFloat(0)));
         NodeDropdown opSelector = new NodeDropdown(this, otherElements.size(), s -> {
-            BoolOperation op = BoolOperation.getByName(s);
-            if (op != null) setOperation(op);
+            BoolOp chosen = BoolOpRegistry.byDisplayName(s);
+            if (chosen != null) setOperation(chosen);
             return null;
-        }, () -> op.name());
-        for (BoolOperation op : BoolOperation.values()) {
-            opSelector.list.addItems(op.name());
+        }, () -> op != null ? op.displayName : "AND");
+
+        for (BoolOp m : BoolOpRegistry.all()) {
+            opSelector.list.addItems(m.displayName);
         }
         this.otherElements.add(opSelector);
-        setOperation(BoolOperation.AND);
+
+        setOperation(BoolOpRegistry.byId(opId));
         evalCache = new DataValue[1];
     }
 
+    private void setOperation(BoolOp newOp) {
+        if (newOp == null) newOp = BoolOpRegistry.byId("and");
+        this.op = newOp;
+        this.opId = newOp.id;
+        for (NodeConnection c : inputs) c.removeConnection();
+        this.inputs.clear();
+
+        for (int i = 0; i < op.arity; i++) {
+            String label = op.inputLabels[i];
+            this.inputs.add(new NodeConnection(label, this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
+        }
+        recalcSize();
+        invalidateCache();
+    }
+
+    private void invalidateCache() {
+        cacheValid = false;
+        evalCache[0] = null;
+    }
+
+    public NodeBoolean setData(BoolOp newOp) {
+        setOperation(newOp);
+        return this;
+    }
+
+    public NodeBoolean setData(String id) {
+        setOperation(BoolOpRegistry.byId(id));
+        return this;
+    }
+
     @Override
     public NodeType getType() {
         return NodeType.BOOLEAN;
@@ -31,88 +73,115 @@
 
     @Override
     public String getDisplayName() {
-        return op.name();
+        return op != null ? op.displayName : "Boolean";
     }
 
     @Override
     public NBTTagCompound writeToNBT(NBTTagCompound tag, NodeSystem sys) {
         tag.setString("nodeType", "boolean");
-        tag.setInteger("op", op.ordinal());
+        tag.setString("opId", opId);
         return super.writeToNBT(tag, sys);
     }
 
     @Override
     public void readFromNBT(NBTTagCompound tag, NodeSystem sys) {
-        op = BoolOperation.values()[tag.getInteger("op")%BoolOperation.values().length];
+        String id = tag.hasKey("opId", Constants.NBT.TAG_STRING) ? tag.getString("opId") : null;
+        setOperation(BoolOpRegistry.byId(id));
         super.readFromNBT(tag, sys);
     }
 
     @Override
     public DataValue evaluate(int idx) {
-        if (cacheValid)
-            return evalCache[0];
+        if (cacheValid) return evalCache[0];
         cacheValid = true;
 
-        DataValue[] evals = new DataValue[inputs.size()];
-        for (int i=0; i < evals.length; i++) {
-            evals[i] = inputs.get(i).evaluate();
-            if (evals[i] == null)
+        final int n = inputs.size();
+        boolean[] args = new boolean[n];
+        for (int i = 0; i < n; i++) {
+            DataValue v = inputs.get(i).evaluate();
+            if (v == null) {
+                cacheValid = false;
                 return null;
+            }
+            args[i] = v.getBoolean();
         }
+
+        boolean out = op.eval(args);
+        return evalCache[0] = new DataValueFloat(out);
+    }
+
+    public static final class BoolOp {
+        public final String id;
+        public final String displayName;
+        public final int arity;
+        public final String[] inputLabels;
+        private final Fn fn;
+
+        private BoolOp(String id, String displayName, int arity, String[] inputLabels, Fn fn) {
+            this.id = Objects.requireNonNull(id);
+            this.displayName = Objects.requireNonNull(displayName);
+            this.arity = arity;
+            this.inputLabels = inputLabels != null ? inputLabels.clone() : defaultLabels(arity);
+            this.fn = Objects.requireNonNull(fn);
+            if (this.inputLabels.length != arity) {
+                throw new IllegalArgumentException("inputLabels length must equal arity");
+            }
+        }
+
+        private static String[] defaultLabels(int n) {
+            String[] names = new String[n];
+            for (int i = 0; i < n; i++) names[i] = "Input " + (i + 1);
+            return names;
+        }
 
-        switch (op) {
-            case AND: return evalCache[0] = new DataValueFloat(evals[0].getBoolean() && evals[1].getBoolean());
-            case OR: return evalCache[0] = new DataValueFloat(evals[0].getBoolean() || evals[1].getBoolean());
-            case NOT: return evalCache[0] = new DataValueFloat(!evals[0].getBoolean());
-            case XOR: return evalCache[0] = new DataValueFloat(evals[0].getBoolean() ^ evals[1].getBoolean());
-            case NAND: return evalCache[0] = new DataValueFloat(!(evals[0].getBoolean() && evals[1].getBoolean()));
-            case NOR: return evalCache[0] = new DataValueFloat(!(evals[0].getBoolean() || evals[1].getBoolean()));
-            case XNOR: return evalCache[0] = new DataValueFloat(evals[0].getBoolean() == evals[1].getBoolean());
+        public static Builder builder(String id, String displayName) {
+            return new Builder(id, displayName);
         }
 
-        return evalCache[0] = null;
-    }
+        public boolean eval(boolean[] in) {
+            return fn.eval(in);
+        }
 
-    public void setOperation(BoolOperation op) {
-        this.op = op;
-        for (NodeConnection c : inputs) {
-            c.removeConnection();
+        @Override
+        public String toString() {
+            return "BoolOp{" + id + ", " + displayName + ", arity=" + arity + ", labels=" + Arrays.toString(inputLabels) + "}";
         }
-        this.inputs.clear();
-        String s1 = "Input 1";
-        String s2 = "Input 2";
 
-        if (op == BoolOperation.NOT) {
-            inputs.add(new NodeConnection("Input", this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-        } else {
-            inputs.add(new NodeConnection(s1, this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-            inputs.add(new NodeConnection(s2, this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
+        @FunctionalInterface
+        public interface Fn {
+            boolean eval(boolean[] a);
         }
 
-        recalcSize();
-    }
+        public static final class Builder {
+            private final String id;
+            private final String name;
+            private int arity = 2;
+            private String[] labels = null;
+            private Fn fn;
+
+            private Builder(String id, String name) {
+                this.id = id;
+                this.name = name;
+            }
 
-    public NodeBoolean setData(BoolOperation op) {
-        setOperation(op);
-        return this;
-    }
+            public Builder arity(int n) {
+                this.arity = n;
+                return this;
+            }
+
+            public Builder labels(String... labels) {
+                this.labels = labels;
+                return this;
+            }
+
+            public Builder eval(Fn fn) {
+                this.fn = fn;
+                return this;
+            }
 
-    public enum BoolOperation {
-        AND,
-        OR,
-        NOT,
-        XOR,
-        NAND,
-        NOR,
-        XNOR;
-
-        public static BoolOperation getByName(String name) {
-            for (BoolOperation o : BoolOperation.values()) {
-                if (o.name().equals(name)) {
-                    return o;
-                }
+            public BoolOp build() {
+                return new BoolOp(id, name, arity, labels, fn);
             }
-            return null;
         }
     }
 }
Index: src/main/java/com/hbm/inventory/control_panel/nodes/NodeMath.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/nodes/NodeMath.java b/src/main/java/com/hbm/inventory/control_panel/nodes/NodeMath.java
--- a/src/main/java/com/hbm/inventory/control_panel/nodes/NodeMath.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/inventory/control_panel/nodes/NodeMath.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -2,183 +2,179 @@
 
 import com.hbm.inventory.control_panel.*;
 import com.hbm.inventory.control_panel.DataValue.DataType;
+import com.hbm.inventory.control_panel.nodes.registry.MathOpRegistry;
 import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.util.math.MathHelper;
+
+import java.util.Arrays;
+import java.util.Objects;
 
 public class NodeMath extends Node {
 
-	public Operation op = Operation.ADD;
-	
-	public NodeMath(float x, float y){
-		super(x, y);
-		this.outputs.add(new NodeConnection("Output", this, outputs.size(), false, DataType.NUMBER, new DataValueFloat(0)));
-		NodeDropdown opSelector = new NodeDropdown(this, otherElements.size(), s -> {
-			Operation op = Operation.getByName(s);
-			if(op != null){
-				setOperation(op);
-			}
-			return null;
-		}, () -> op.name);
-		for(Operation op : Operation.values()){
-			opSelector.list.addItems(op.name);
-		}
-		this.otherElements.add(opSelector);
-		setOperation(Operation.ADD);
-		evalCache = new DataValue[1];
-	}
-	
-	@Override
-	public NBTTagCompound writeToNBT(NBTTagCompound tag, NodeSystem sys){
-		tag.setString("nodeType", "math");
-		tag.setInteger("op", op.ordinal());
-		return super.writeToNBT(tag, sys);
-	}
-	
-	@Override
-	public void readFromNBT(NBTTagCompound tag, NodeSystem sys){
-		op = Operation.values()[tag.getInteger("op")%Operation.values().length];
-		super.readFromNBT(tag, sys);
-	}
-	
-	@Override
-	public DataValue evaluate(int idx){
-		if(cacheValid)
-			return evalCache[0];
-		cacheValid = true;
-		DataValue[] evals = new DataValue[inputs.size()];
-		for(int i = 0; i < evals.length; i ++){
-			evals[i] = inputs.get(i).evaluate();
-			if(evals[i] == null)
-				return null;
-		}
-		switch(op) {
-			case ADD:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber()+evals[1].getNumber());
-			case SUB:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber()-evals[1].getNumber());
-			case MULT:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber()*evals[1].getNumber());
-			case DIV:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber()/evals[1].getNumber());
-			case MOD:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber()%evals[1].getNumber());
-			case POW:
-				return evalCache[0] = new DataValueFloat((float)Math.pow(evals[0].getNumber(), evals[1].getNumber()));
-			case LOG:
-				return evalCache[0] = new DataValueFloat((float)(Math.log(evals[0].getNumber())/Math.log(evals[1].getNumber())));
-			case EXP:
-				return evalCache[0] = new DataValueFloat((float)Math.exp(evals[0].getNumber()));
-			case SQRT:
-				return evalCache[0] = new DataValueFloat((float)Math.sqrt(evals[0].getNumber()));
-			case ABS:
-				return evalCache[0] = new DataValueFloat(Math.abs(evals[0].getNumber()));
-			case EQUAL:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber() == evals[1].getNumber() ? 1 : 0);
-			case GREATER:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber() > evals[1].getNumber() ? 1 : 0);
-			case LESS:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber() < evals[1].getNumber() ? 1 : 0);
-			case GEQUAL:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber() >= evals[1].getNumber() ? 1 : 0);
-			case LEQUAL:
-				return evalCache[0] = new DataValueFloat(evals[0].getNumber() <= evals[1].getNumber() ? 1 : 0);
-			case CLAMP:
-				return evalCache[0] = new DataValueFloat(MathHelper.clamp(evals[0].getNumber(), evals[1].getNumber(), evals[2].getNumber()));
-		}
-		return evalCache[0] = null;
-	}
-
-	public NodeMath setData(Operation op) {
-		setOperation(op);
-		return this;
-	}
+    private MathOp op;
+    private String opId;
+
+    public NodeMath(float x, float y) {
+        this(x, y, "add");
+    }
+
+    public NodeMath(float x, float y, String opId) {
+        super(x, y);
+        this.outputs.add(new NodeConnection("Output", this, outputs.size(), false, DataType.NUMBER, new DataValueFloat(0)));
+        NodeDropdown opSelector = new NodeDropdown(this, otherElements.size(), s -> {
+            MathOp chosen = MathOpRegistry.byDisplayName(s);
+            if (chosen != null) setOperation(chosen);
+            return null;
+        }, () -> op != null ? op.displayName : "Add");
+
+        for (MathOp m : MathOpRegistry.all()) {
+            opSelector.list.addItems(m.displayName);
+        }
+        this.otherElements.add(opSelector);
+
+        setOperation(MathOpRegistry.byId(opId));
+        evalCache = new DataValue[1];
+    }
+
+    private void setOperation(MathOp newOp) {
+        if (newOp == null) newOp = MathOpRegistry.byId("add");
+        this.op = newOp;
+        this.opId = newOp.id;
+        for (NodeConnection c : inputs) c.removeConnection();
+        this.inputs.clear();
+        for (int i = 0; i < op.arity; i++) {
+            String label = op.inputLabels[i];
+            this.inputs.add(new NodeConnection(label, this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
+        }
+        recalcSize();
+        invalidateCache();
+    }
+
+    public NodeMath setData(MathOp op) {
+        setOperation(op);
+        return this;
+    }
+
+    private void invalidateCache() {
+        cacheValid = false;
+        evalCache[0] = null;
+    }
+
+    @Override
+    public NBTTagCompound writeToNBT(NBTTagCompound tag, NodeSystem sys) {
+        tag.setString("nodeType", "math");
+        tag.setString("opId", opId);
+        return super.writeToNBT(tag, sys);
+    }
+
+    @Override
+    public void readFromNBT(NBTTagCompound tag, NodeSystem sys) {
+        MathOp candidate = MathOpRegistry.byId(tag.getString("opId"));
+        setOperation(candidate);
+        super.readFromNBT(tag, sys);
+    }
+
+    @Override
+    public DataValue evaluate(int idx) {
+        if (cacheValid) return evalCache[0];
+        cacheValid = true;
+
+        final int n = inputs.size();
+        float[] args = new float[n];
+        for (int i = 0; i < n; i++) {
+            DataValue v = inputs.get(i).evaluate();
+            if (v == null) {
+                cacheValid = false;
+                return null;
+            }
+            args[i] = v.getNumber();
+        }
 
-	public void setOperation(Operation op){
-		this.op = op;
-		for(NodeConnection c : inputs){
-			c.removeConnection();
-		}
-		this.inputs.clear();
-		String s1 = "Input 1";
-		String s2 = "Input 2";
-		switch(op) {
-			case EQUAL:
-			case GREATER:
-			case LESS:
-			case GEQUAL:
-			case LEQUAL:
-			case ADD:
-			case SUB:
-			case MULT:
-			case DIV:
-			case MOD:
-			case POW:
-			case LOG:
-				if(op == Operation.POW){
-					s1 = "Base";
-					s2 = "Exponent";
-				} else if(op == Operation.LOG){
-					s1 = "Value";
-					s2 = "Base";
-				}
-				inputs.add(new NodeConnection(s1, this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-				inputs.add(new NodeConnection(s2, this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-				break;
-			case EXP:
-			case SQRT:
-			case ABS:
-				inputs.add(new NodeConnection("Input", this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-				break;
-			case CLAMP:
-				inputs.add(new NodeConnection("Value", this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-				inputs.add(new NodeConnection("Min", this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-				inputs.add(new NodeConnection("Max", this, inputs.size(), true, DataType.NUMBER, new DataValueFloat(0)));
-				break;
-		}
-		recalcSize();
-	}
-	
-	@Override
-	public NodeType getType(){
-		return NodeType.MATH;
-	}
-	
-	@Override
-	public String getDisplayName(){
-		return op.name;
-	}
-	
-	public static enum Operation {
-		ADD("Add"),
-		SUB("Subtract"),
-		MULT("Multiply"),
-		DIV("Divide"),
-		MOD("Modulo"),
-		POW("Power"),
-		LOG("Logarithm"),
-		EXP("Exponent"),
-		SQRT("Square root"),
-		ABS("Absolute"),
-		EQUAL("Equal"),
-		GREATER("Greater"),
-		LESS("Less"),
-		GEQUAL("Greater/equal"),
-		LEQUAL("Less/equal"),
-		CLAMP("Clamp");
+        float out = op.eval(args);
+        return evalCache[0] = new DataValueFloat(out);
+    }
+
+    @Override
+    public NodeType getType() {
+        return NodeType.MATH;
+    }
+
+    @Override
+    public String getDisplayName() {
+        return op != null ? op.displayName : "Math";
+    }
+
+    public static final class MathOp {
+        public final String id;
+        public final String displayName;
+        public final int arity;
+        public final String[] inputLabels;
+        private final FloatN fn;
+
+        private MathOp(String id, String displayName, int arity, String[] inputLabels, FloatN fn) {
+            this.id = Objects.requireNonNull(id);
+            this.displayName = Objects.requireNonNull(displayName);
+            this.arity = arity;
+            this.inputLabels = inputLabels != null ? inputLabels.clone() : defaultLabels(arity);
+            this.fn = Objects.requireNonNull(fn);
+            if (this.inputLabels.length != arity) {
+                throw new IllegalArgumentException("inputLabels length must equal arity");
+            }
+        }
+
+        private static String[] defaultLabels(int n) {
+            String[] names = new String[n];
+            for (int i = 0; i < n; i++) names[i] = "Input " + (i + 1);
+            return names;
+        }
+
+        public static Builder builder(String id, String displayName) {
+            return new Builder(id, displayName);
+        }
+
+        public float eval(float[] in) {
+            return fn.eval(in);
+        }
+
+        @Override
+        public String toString() {
+            return "MathOp{" + id + ", " + displayName + ", arity=" + arity + ", labels=" + Arrays.toString(inputLabels) + "}";
+        }
 
-		public String name;
-		private Operation(String name){
-			this.name = name;
-		}
-		
-		public static Operation getByName(String name){
-			for(Operation o : values()){
-				if(o.name.equals(name)){
-					return o;
-				}
-			}
-			return null;
-		}
-	}
+        @FunctionalInterface
+        public interface FloatN {
+            float eval(float[] a);
+        }
+
+        public static final class Builder {
+            private final String id;
+            private final String name;
+            private int arity = 2;
+            private String[] labels = null;
+            private FloatN fn;
+
+            private Builder(String id, String name) {
+                this.id = id;
+                this.name = name;
+            }
+
+            public Builder arity(int n) {
+                this.arity = n;
+                return this;
+            }
+
+            public Builder labels(String... labels) {
+                this.labels = labels;
+                return this;
+            }
+
+            public Builder eval(FloatN fn) {
+                this.fn = fn;
+                return this;
+            }
 
+            public MathOp build() {
+                return new MathOp(id, name, arity, labels, fn);
+            }
+        }
+    }
 }
Index: src/main/java/com/hbm/inventory/control_panel/nodes/registry/BoolOpRegistry.java
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/nodes/registry/BoolOpRegistry.java b/src/main/java/com/hbm/inventory/control_panel/nodes/registry/BoolOpRegistry.java
new file mode 100644
--- /dev/null	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
+++ b/src/main/java/com/hbm/inventory/control_panel/nodes/registry/BoolOpRegistry.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -0,0 +1,51 @@
+package com.hbm.inventory.control_panel.nodes.registry;
+
+import com.hbm.inventory.control_panel.nodes.NodeBoolean;
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
+
+import java.util.Collection;
+import java.util.Map;
+
+public final class BoolOpRegistry {
+    // don't use directly
+    public static final Map<String, NodeBoolean.BoolOp> BY_ID = new Object2ObjectLinkedOpenHashMap<>(16);
+    public static final Map<String, String> NAME_TO_ID = new Object2ObjectLinkedOpenHashMap<>(16);
+
+    private BoolOpRegistry() {}
+
+    public static NodeBoolean.BoolOp register(NodeBoolean.BoolOp op) {
+        if (BY_ID.containsKey(op.id)) throw new IllegalArgumentException("Duplicate bool op id: " + op.id);
+        if (NAME_TO_ID.containsKey(op.displayName)) throw new IllegalArgumentException("Duplicate bool op displayName: " + op.displayName);
+        BY_ID.put(op.id, op);
+        NAME_TO_ID.put(op.displayName, op.id);
+        return op;
+    }
+
+    public static NodeBoolean.BoolOp byId(String id) {
+        if (BY_ID.isEmpty()) init();
+        return id != null ? BY_ID.get(id) : null;
+    }
+
+    public static NodeBoolean.BoolOp byDisplayName(String name) {
+        if (BY_ID.isEmpty()) init();
+        String id = NAME_TO_ID.get(name);
+        return id != null ? BY_ID.get(id) : null;
+    }
+
+    public static Collection<NodeBoolean.BoolOp> all() {
+        if (BY_ID.isEmpty()) init();
+        return BY_ID.values();
+    }
+
+    public static void init() {
+        if (!BY_ID.isEmpty()) return;
+
+        register(NodeBoolean.BoolOp.builder("and","AND").arity(2).labels("A","B").eval(a -> a[0] && a[1]).build());
+        register(NodeBoolean.BoolOp.builder("or","OR").arity(2).labels("A","B").eval(a -> a[0] || a[1]).build());
+        register(NodeBoolean.BoolOp.builder("not","NOT").arity(1).labels("Input").eval(a -> !a[0]).build());
+        register(NodeBoolean.BoolOp.builder("xor","XOR").arity(2).labels("A","B").eval(a -> a[0] ^ a[1]).build());
+        register(NodeBoolean.BoolOp.builder("nand","NAND").arity(2).labels("A","B").eval(a -> !(a[0] && a[1])).build());
+        register(NodeBoolean.BoolOp.builder("nor","NOR").arity(2).labels("A","B").eval(a -> !(a[0] || a[1])).build());
+        register(NodeBoolean.BoolOp.builder("xnor","XNOR").arity(2).labels("A","B").eval(a -> a[0] == a[1]).build());
+    }
+}
Index: src/main/java/com/hbm/inventory/control_panel/nodes/registry/MathOpRegistry.java
===================================================================
diff --git a/src/main/java/com/hbm/inventory/control_panel/nodes/registry/MathOpRegistry.java b/src/main/java/com/hbm/inventory/control_panel/nodes/registry/MathOpRegistry.java
new file mode 100644
--- /dev/null	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
+++ b/src/main/java/com/hbm/inventory/control_panel/nodes/registry/MathOpRegistry.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -0,0 +1,59 @@
+package com.hbm.inventory.control_panel.nodes.registry;
+
+import com.hbm.inventory.control_panel.nodes.NodeMath;
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
+import net.minecraft.util.math.MathHelper;
+
+import java.util.Collection;
+import java.util.Map;
+
+public final class MathOpRegistry {
+    // don't use directly, call via api whenever possible
+    public static final Map<String, NodeMath.MathOp> BY_ID = new Object2ObjectLinkedOpenHashMap<>(32);
+    public static final Map<String, String> NAME_TO_ID = new Object2ObjectLinkedOpenHashMap<>(32);
+
+    private MathOpRegistry() {
+    }
+
+    public static NodeMath.MathOp register(NodeMath.MathOp op) {
+        if (BY_ID.containsKey(op.id)) throw new IllegalArgumentException("Duplicate math op id: " + op.id);
+        if (NAME_TO_ID.containsKey(op.displayName)) throw new IllegalArgumentException("Duplicate math op displayName: " + op.displayName);
+        BY_ID.put(op.id, op);
+        NAME_TO_ID.put(op.displayName, op.id);
+        return op;
+    }
+
+    public static NodeMath.MathOp byId(String id) {
+        return BY_ID.get(id);
+    }
+
+    public static NodeMath.MathOp byDisplayName(String name) {
+        String id = NAME_TO_ID.get(name);
+        return id != null ? BY_ID.get(id) : null;
+    }
+
+    public static Collection<NodeMath.MathOp> all() {
+        return BY_ID.values();
+    }
+
+    public static void init() {
+        if (!BY_ID.isEmpty()) return;
+
+        register(NodeMath.MathOp.builder("add", "Add").arity(2).eval(a -> a[0] + a[1]).build());
+        register(NodeMath.MathOp.builder("sub", "Subtract").arity(2).eval(a -> a[0] - a[1]).build());
+        register(NodeMath.MathOp.builder("mul", "Multiply").arity(2).eval(a -> a[0] * a[1]).build());
+        register(NodeMath.MathOp.builder("div", "Divide").arity(2).eval(a -> a[0] / a[1]).build());
+        register(NodeMath.MathOp.builder("mod", "Modulo").arity(2).eval(a -> a[0] % a[1]).build());
+        register(NodeMath.MathOp.builder("pow", "Power").arity(2).labels("Base", "Exponent").eval(a -> (float) Math.pow(a[0], a[1])).build());
+        register(NodeMath.MathOp.builder("log", "Logarithm").arity(2).labels("Value", "Base").eval(a -> (float) (Math.log(a[0]) / Math.log(a[1]))).build());
+        register(NodeMath.MathOp.builder("exp", "Exponent").arity(1).labels("Input").eval(a -> (float) Math.exp(a[0])).build());
+        register(NodeMath.MathOp.builder("sqrt", "Square root").arity(1).labels("Input").eval(a -> (float) Math.sqrt(a[0])).build());
+        register(NodeMath.MathOp.builder("abs", "Absolute").arity(1).labels("Input").eval(a -> Math.abs(a[0])).build());
+        register(NodeMath.MathOp.builder("eq", "Equal").arity(2).eval(a -> a[0] == a[1] ? 1f : 0f).build());
+        register(NodeMath.MathOp.builder("gt", "Greater").arity(2).eval(a -> a[0] > a[1] ? 1f : 0f).build());
+        register(NodeMath.MathOp.builder("lt", "Less").arity(2).eval(a -> a[0] < a[1] ? 1f : 0f).build());
+        register(NodeMath.MathOp.builder("ge", "Greater/equal").arity(2).eval(a -> a[0] >= a[1] ? 1f : 0f).build());
+        register(NodeMath.MathOp.builder("le", "Less/equal").arity(2).eval(a -> a[0] <= a[1] ? 1f : 0f).build());
+        register(NodeMath.MathOp.builder("clamp", "Clamp").arity(3).labels("Value", "Min", "Max").eval(a -> MathHelper.clamp(a[0], a[1], a[2])).build());
+    }
+}
Index: src/main/java/com/hbm/main/MainRegistry.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/hbm/main/MainRegistry.java b/src/main/java/com/hbm/main/MainRegistry.java
--- a/src/main/java/com/hbm/main/MainRegistry.java	(revision 9079ab375bc7ca244ed1d0ea076289f33b7298d9)
+++ b/src/main/java/com/hbm/main/MainRegistry.java	(revision 5173dbdda74136e2e17e9b1381aec27c10995f25)
@@ -37,6 +37,8 @@
 import com.hbm.inventory.RecipesCommon;
 import com.hbm.inventory.control_panel.ControlEvent;
 import com.hbm.inventory.control_panel.ControlRegistry;
+import com.hbm.inventory.control_panel.nodes.Node;
+import com.hbm.inventory.control_panel.nodes.registry.MathOpRegistry;
 import com.hbm.inventory.fluid.Fluids;
 import com.hbm.inventory.recipes.*;
 import com.hbm.inventory.recipes.anvil.AnvilRecipes;
@@ -398,6 +400,7 @@
         Fluids.initForgeFluidCompat();
         PacketThreading.init();
         IMCHandler.init();
+        Node.registerOps();
     }
 
     @EventHandler
